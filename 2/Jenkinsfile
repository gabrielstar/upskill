import groovy.transform.Field

def NODE_LABEL = "MM-CPU"
@Field def MODULES_DIR = "ci/lib"
@Field def JOB = "mlops/wave-app/e2e_fe_tests"
@Field def PARALLEL_MARKERS = ['thread1','thread2']
// UID and GID are user and group on which Jenkins runs. This is needed because we cannot change how Jenkins runs
// docker. We need to adjust docker image instead.
@Field def UID = 2117
@Field def GID = 2117

@Field def JENKINS_URL = "http://mr-0xg1:8080/job/mlops"
@Field def PLAYWRIGHT_IMAGE = "gcr.io/vorvan/h2oai/playwright:1.14.1"
@Field def H2O_CLI_IMAGE = "gcr.io/vorvan/h2oai/h2o-cli:latest"
@Field def HEAP_ANALYTICS_ENABLED = "false"
@Field def USER_PILOT_TOKEN = "invalid"
@Field def MLOPS_AZURE_INTEGRATION_ENABLED = "false"
@Field def MLOPS_AZURE_CLIENT_SCOPES = "mlops_no_scopes"
@Field def MLOPS_AZURE_TOKEN_ENDPOINT = "https://login.microsoftonline.com/840229f2-c911-49e6-a73d-5b3a4311835a/oauth2/v2.0"
@Field def MLFLOW_EXPERIMENT_IMPORT_ENABLED = "false"

def GCR = "gcr.io"
def GCR_PATH = "gcr.io/vorvan/h2oai/mlops-wave-app-standalone"
def GCR_CREDENTIAL = "MM_GCR_VORVAN_CREDENTIALS"

def HARBOR = "harbor.h2o.ai"
def HARBOR_PATH = "harbor.h2o.ai/opsh2oai/mlops-wave-app-standalone"
def HARBOR_CREDENTIAL = "harbor.h2o.ai"


properties([
        disableConcurrentBuilds(),
        buildDiscarder(logRotator(daysToKeepStr: '30')),
        buildDiscarder(logRotator(numToKeepStr: "10")),
        parameters([
                stringParam(
                        name: 'HAC_CLOUD_URL',
                        defaultValue: 'https://cloud-qa.h2o.ai',
                        description: 'H2O AI Cloud URL',
                ),
                stringParam(
                        name: "MLOPS_GATEWAY_URL",
                        defaultValue: 'https://mlops-api.cloud-qa.h2o.ai',
                        description: 'API URL e.g. https://mlops-api.cloud-qa.h2o.ai or https://api.XY-test.mlops-dev.h2o.ai'
                ),
                stringParam(
                        defaultValue: 'h2o-cli-config-toml-h2omlops-tester-qa',
                        description: "Name of Jenkins file credentials with h2o-cli-config.toml (used for app deployment).",
                        name: "H2O_CLI_CREDENTIALS"
                ),
                stringParam(
                        defaultValue: 'h2omlops-tester-qa',
                        description: "Name of Jenkins credentials with username and password (used for login in app test)",
                        name: "H2O_USER_CREDENTIALS"
                ),
                stringParam(
                        name: "OTP_SECRET_CREDENTIALS",
                        defaultValue: "cloud-internal-h2omlops-tester-otp-secret",
                        description: 'OTP_SECRET of user1 if using google login'
                ),
                stringParam(
                        name: "OTP_SECRET2_CREDENTIALS",
                        defaultValue: "cloud-internal-h2omlops-tester2-otp-secret",
                        description: 'OTP_SECRET of user2 if using google login'
                ),
                booleanParam(
                        name: 'RUN_E2E_TESTS',
                        defaultValue: true,
                        description: 'Whether to run E2E Tests.'
                ),
                choice(
                        choices: ['smoke', 'monitoring', 'sharing', 'deployment', 'performance', 'batch', 'no_test', 'project', 'current', ''],
                        description: "Select which tests to run. All valid values can be found at https://github.com/h2oai/mlops-wave-app/blob/dra/ci/add-missing-e2e-markers/setup.cfg#L15",
                        name: "E2E_TEST_SELECTOR"),
                stringParam(
                        name: 'APP_DELETE_GRACE_PERIOD',
                        defaultValue: '1',
                        description: 'How long to wait [s] before deleting the app. Useful for troubleshooting UI errors.',
                ),
                booleanParam(
                        name: 'PUSH_TO_HARBOR',
                        defaultValue: false,
                        description: 'Whether to push docker image to H2O.ai Harbor.'
                ),
                booleanParam(
                        name: 'PUSH_TO_VORVAN',
                        defaultValue: false,
                        description: 'Whether to push docker image to Vorvaň GCR repository.'
                ),
                booleanParam(
                        name: 'BUILD_DOCKER_WITH_CONDA',
                        defaultValue: false,
                        description: 'Whether to build additional docker image with conda envs for MLFlow experiments.'
                ),
                stringParam(
                        name: 'JENKINS_CREDENTIALS',
                        defaultValue: "JENKINS_MLOPS_TOKEN",
                        description: 'User credentials to use to trigger performance job remotely (required if using @performance tag)'
                ),
                stringParam(
                        name: "ESCORER_APP_URL",
                        defaultValue: 'https://escorer-011.cloud-qa.h2o.ai/',
                        description: 'EScorer App url'
                )
        ])
])

ansiColor("xterm") {
    timestamps {
        node(NODE_LABEL) {
            def HAC_CLOUD_URL = params.getOrDefault('HAC_CLOUD_URL', 'https://cloud-qa.h2o.ai')
            def GATEWAY_URL = params.getOrDefault('MLOPS_GATEWAY_URL', 'https://mlops-api.cloud-qa.h2o.ai')
            def ESCORER_APP_URL = params.ESCORER_APP_URL
            def H2O_CLI_CREDENTIALS = params.getOrDefault('H2O_CLI_CREDENTIALS', 'h2o-cli-config-toml-h2omlops-tester')
            def H2O_USER_CREDENTIALS = params.getOrDefault('H2O_USER_CREDENTIALS', 'cloudQA-h2omlops-tester')
            def E2E_TEST_SELECTOR = params.getOrDefault('E2E_TEST_SELECTOR', 'smoke')
            def APP_DELETE_GRACE_PERIOD = params.getOrDefault('APP_DELETE_GRACE_PERIOD', '1')
            def OTP_SECRET_CREDENTIALS = params.getOrDefault('OTP_SECRET_CREDENTIALS', 'cloud-internal-h2omlops-tester-otp-secret')
            def OTP_SECRET2_CREDENTIALS = params.getOrDefault('OTP_SECRET2_CREDENTIALS', 'cloud-internal-h2omlops-tester2-otp-secret')
            def h2oImage = ""
            def playwrightImage = ""
            def appID = ""
            def appInstanceID = ""
            def appInstanceURL = ""
            stage("0. Init") {
                deleteDir()
                checkout scm
                utils = load "${MODULES_DIR}/utils.groovy"
            }
            stage("1. Pull images") {
                parallel([
                        "1.1 H2O CLI"   : {
                            h2oImage = docker.image(H2O_CLI_IMAGE)
                            h2oImage.pull()
                        },
                        "1.2 Playwright": {
                            playwrightImage = docker.image(PLAYWRIGHT_IMAGE)
                            playwrightImage.pull()
                        }
                ])
            }

            h2oImage.inside() {
                stage("2. Install app and testing deps") {
                    sh "git config --unset-all core.hooksPath"
                    sh "make setup-ci"
                }
                stage("3. Code style") {
                    def logFile = "reports/flake8.log"
                    try {
                        sh "make lint-ci"
                    } finally {
                        def report = readFile(file: logFile)
                        if (report) {
                            reportFlake8Violations(report)
                            archiveArtifacts artifacts: logFile, fingerprint: true
                        }
                    }
                }
                stage("4. Unit tests") {
                    try {
                        sh "make test-unit-ci"
                    } finally {
                        junit "reports/*xml"
                        step([
                                $class             : 'CoberturaPublisher',
                                autoUpdateHealth   : false,
                                autoUpdateStability: false,
                                coberturaReportFile: 'reports/coverage.xml',
                                failUnhealthy      : false,
                                failUnstable       : false,
                                maxNumberOfBuilds  : 0,
                                onlyStable         : false,
                                sourceEncoding     : 'ASCII',
                                zoomCoverageChart  : false
                        ])
                    }
                }
                if (params.RUN_E2E_TESTS) {
                    stage("5. Deploy application") {
                        def logFile = "reports/h2o-bundle-deploy.log"
                        withH2OCLICredentials(H2O_CLI_CREDENTIALS) {
                            // create or update credentials
                            String command = './scripts/setup.sh $H2O_CLI_CONFIG_TOML ' +
                                    "${HEAP_ANALYTICS_ENABLED} " +
                                    "${USER_PILOT_TOKEN} " +
                                    "${ESCORER_APP_URL} " +
                                    "${MLOPS_AZURE_INTEGRATION_ENABLED} " +
                                    "${MLOPS_AZURE_CLIENT_SCOPES} " +
                                    "${MLOPS_AZURE_TOKEN_ENDPOINT}" +
                                    "${MLFLOW_EXPERIMENT_IMPORT_ENABLED}"
                            sh "$command"

                            try {
                                sh """#!/usr/bin/env bash
                                        set -euo pipefail
                                        h2o --conf=\${H2O_CLI_CONFIG_TOML} bundle deploy -v ALL_USERS 2>&1 | tee -a ${logFile}
                                    """
                                sh "grep -e '^ID' -e '^URL' ${logFile} > ids.txt"
                            } finally {
                                archiveArtifacts artifacts: logFile, fingerprint: true
                            }
                            appID = sh(script: "head -n 1 ids.txt | awk \'{print \$2}\'", returnStdout: true,).trim()
                            appInstanceID = sh(script: "tail -2 ids.txt | head -n 1 | awk \'{print \$2}\'", returnStdout: true,).trim()
                            appInstanceURL = sh(script: "tail -n 1 ids.txt | awk \'{print \$2}\'", returnStdout: true,).trim()
                            print "Deployed instance=${appInstanceID} of app id=${appID} at ${appInstanceURL}"
                        }
                    }
                }
            }
            if (params.RUN_E2E_TESTS) {
                try {
                    stage("6. E2E tests") {
                        withCredentials([
                                usernamePassword(
                                        credentialsId: H2O_USER_CREDENTIALS,
                                        passwordVariable: 'HAC_PASSWORD',
                                        usernameVariable: 'HAC_USERNAME'
                                ),
                                string(credentialsId: OTP_SECRET_CREDENTIALS, variable: 'OTP_SECRET'),
                                string(credentialsId: OTP_SECRET2_CREDENTIALS, variable: 'OTP_SECRET2'),
                                usernamePassword(
                                        credentialsId: params.JENKINS_CREDENTIALS,
                                        passwordVariable: 'JENKINS_PASSWORD',
                                        usernameVariable: 'JENKINS_USERNAME'
                                ),
                        ]) {
                            try {
                                h2oImage.inside() {
                                    withH2OCLICredentials(H2O_CLI_CREDENTIALS) {
                                        platformToken = sh(script: "h2o --conf=\${H2O_CLI_CONFIG_TOML} platform refresh-token", returnStdout: true,).trim()
                                        platformTokenEndpoint = sh(script: "h2o --conf=\${H2O_CLI_CONFIG_TOML} platform token-info | grep \'Token Endpoint URL\' | awk \'{print \$4}\'", returnStdout: true,).trim()
                                        clientID = sh(script: "h2o --conf=\${H2O_CLI_CONFIG_TOML} platform token-info | grep \'Client ID\' | awk \'{print \$3}\'", returnStdout: true,).trim()
                                    }
                                }

                                def user_params = [
                                        stringParam(name: 'APP_INSTANCE_URL', value: appInstanceURL),
                                        stringParam(name: 'GATEWAY_URL', value: GATEWAY_URL),
                                        stringParam(name: 'PLATFORM_TOKEN', value: platformToken),
                                        stringParam(name: 'PLATFORM_TOKEN_ENDPOINT', value: platformTokenEndpoint),
                                        stringParam(name: 'CLIENT_ID', value: clientID),
                                        stringParam(name: 'JENKINS_URL', value: JENKINS_URL),
                                        stringParam(name: 'JENKINS_USERNAME', value: JENKINS_USERNAME),
                                        stringParam(name: 'JENKINS_PASSWORD', value: JENKINS_PASSWORD),
                                        stringParam(name: 'TEST_USER_PASSWORD', value: HAC_PASSWORD),
                                        stringParam(name: 'TEST_USER_NAME', value: HAC_USERNAME),
                                ]
                                def testBranch = scm.branches[0].name
                                if (isPR()) {
                                    testBranch = env.CHANGE_BRANCH
                                }
                                target = "${JOB}/${java.net.URLEncoder.encode(testBranch,  "UTF-8")}"
                                parallel(utils.buildParallelJobs("FE Tests", target, user_params, PARALLEL_MARKERS, E2E_TEST_SELECTOR, ""))
                            } finally {
                                utils.joinReports()
                            }
                        }
                    }

                    stage("7. Sleep") {
                        sh """
                            sleep ${APP_DELETE_GRACE_PERIOD}
                        """
                    }

                } finally {
                    stage("8. Delete application") {
                        def logFile = "reports/h2o-app-delete.log"
                        try {
                            h2oImage.inside() {
                                withH2OCLICredentials(H2O_CLI_CREDENTIALS) {
                                    sh "h2o --conf=\${H2O_CLI_CONFIG_TOML} app delete ${appID} --terminate-instances 2>&1 | tee -a ${logFile}"
                                }
                            }
                        } finally {
                            archiveArtifacts artifacts: logFile, fingerprint: true
                        }
                    }
                }
            }

        def pushToHarbor = params.PUSH_TO_HARBOR || isMasterBranch() || isReleaseBranch()
        def pushToVorvan = params.PUSH_TO_VORVAN || isMasterBranch() || isReleaseBranch()
        def buildDocker = pushToHarbor || pushToVorvan
        def buildWithCondaEnvs = params.BUILD_DOCKER_WITH_CONDA

        if (buildDocker) {
            String appVersion = sh(script: """ sed -n -e 's/^.*Version = "\\(.*\\)"\$/\\1/p' app.toml """, returnStdout: true).trim()
            def commitHash = getGitCommitHash()
            def commitHashShort = getGitCommitHashShort()
            def cIJobInfo = getCIJobInfo()
            def imageSummary = "Docker images:\n"

            String imageTag = "${appVersion}_${commitHashShort}${cIJobInfo}"
            String imageName = "mlops-wave-app-standalone:${imageTag}"
            String condaImageName = "mlops-wave-app-standalone-conda:${imageTag}"

            def jobBranch = env.CHANGE_BRANCH ?: env.BRANCH_NAME
            jobBranch = jobBranch.replaceAll("/", "_")
            String[] imageTags = [imageTag, "${commitHash}", jobBranch, "${jobBranch}-${env.BUILD_NUMBER}"]

            if (isMasterBranch()) {
                imageTags += "main"
            }

            if (isMainReleaseBranch()) {
                imageTags += "latest"
            }

            try {
                stage("9.1 Build Docker image") {
                    appImage = docker.build(imageName, "./")
                }

                if (pushToHarbor) {
                    stage("9.2 Docker Push to Harbor") {
                        pushToDockerRepository(imageName, HARBOR_PATH, imageTags, HARBOR, HARBOR_CREDENTIAL)
                        imageSummary = imageSummary + "\n" + (imageTags.collect { "${HARBOR_PATH}:${it}" }).join("\n")
                    }
                }

                if (pushToVorvan) {
                    stage("9.3 Docker Push to Vorvaň") {
                        pushToGCR(imageName, GCR_PATH, imageTags, GCR, GCR_CREDENTIAL)
                        imageSummary = imageSummary + "\n" + (imageTags.collect { "${GCR_PATH}:${it}" }).join("\n")
                    }
                }

                if (buildWithCondaEnvs) {
                    String GCR_PATH_WITH_CONDA_ENV = GCR_PATH + "/conda"
                    String HARBOR_PATH_WITH_CONDA_ENV = HARBOR_PATH + "/conda"

                    stage("9.4 Build Docker with Conda") {
                        appImageWithConda = docker.build(condaImageName, "--build-arg BUILD_WITH_CONDA=true ./")
                    }

                    if (pushToHarbor) {
                        stage("9.5 Push Docker with Conda to Harbor") {
                            pushToDockerRepository(condaImageName, HARBOR_PATH_WITH_CONDA_ENV, imageTags, HARBOR, HARBOR_CREDENTIAL)
                            imageSummary = imageSummary + "\n" + (imageTags.collect { "${HARBOR_PATH_WITH_CONDA_ENV}:${it}" }).join("\n")
                        }
                    }

                    if (pushToVorvan) {
                        stage("9.6 Push Docker with Conda to Vorvaň") {
                            pushToGCR(condaImageName, GCR_PATH_WITH_CONDA_ENV, imageTags, GCR, GCR_CREDENTIAL)
                            imageSummary = imageSummary + "\n" + (imageTags.collect { "${GCR_PATH_WITH_CONDA_ENV}:${it}" }).join("\n")
                        }
                    }
                }

            } finally {
                sh(
                        script: "docker rmi -f ${imageName}",
                        returnStatus: true,
                )

                if (buildWithCondaEnvs) {
                    sh(
                            script: "docker rmi -f ${condaImageName}",
                            returnStatus: true,
                    )
                }
            }
            createSummary("fingerprint.png").appendText("<pre>${imageSummary}</pre>")
        }
    }
}
}

def withH2OCLICredentials(credentialsId, body) {
    withCredentials([
            file(
                    credentialsId: credentialsId,
                    variable: "H2O_CLI_CONFIG_TOML"
            ),
    ]) {
        body()
    }
}

def withDockerCredentials(String credentialsId, Closure body) {
    def dockerCredentials = usernamePassword(
            credentialsId: credentialsId,
            passwordVariable: "DOCKER_PASSWORD",
            usernameVariable: "DOCKER_USERNAME"
    )
    withCredentials([dockerCredentials]) {
        body()
    }
}

def withGCRCredentials(String credentialsId, Closure body) {
    def gcrCredentials = file(credentialsId: credentialsId, variable: 'GCR_JSON_KEY')
    withCredentials([gcrCredentials]) {
        body()
    }
}

def getGitCommitHash() {
    return sh(
            script: "git rev-parse --verify HEAD",
            returnStdout: true,
    ).trim()
}

def getGitCommitHashShort() {
    return sh(
            script: "git rev-parse --short HEAD",
            returnStdout: true,
    ).trim()
}

def getCIJobInfo() {
    def jobName = env.JOB_BASE_NAME
    def jobNumber = env.BUILD_NUMBER

    if (!jobName || !jobNumber) {
        return '';
    }

    return '.' + jobName.trim().replace('.', '-').replace('/', '-').replace('%2F', '-') + '.' + jobNumber.trim()
}

def pushToDockerRepository(String sourceImage, String targetImagePath, String[] targetImageTags, String repository, String credentialsId) {
    withDockerCredentials(credentialsId) {
        sh "docker login ${repository} -u ${DOCKER_USERNAME} -p ${DOCKER_PASSWORD}"
        for (tag in targetImageTags) {
            def fullTag = "${targetImagePath}:${tag}"
            sh "docker tag ${sourceImage} ${fullTag}"
            sh "docker push ${fullTag}"
        }
    }
}

def pushToGCR(String sourceImage, String targetImagePath, String[] targetImageTags, String repository, String credentialsId) {
    withGCRCredentials(credentialsId) {
        sh "docker login gcr.io -u _json_key --password-stdin < ${GCR_JSON_KEY}"
        for (tag in targetImageTags) {
            def fullTag = "${targetImagePath}:${tag}"
            sh "docker tag ${sourceImage} ${fullTag}"
            sh "docker push ${fullTag}"
        }

    }
}

def isPR() {
    return (env.BRANCH_NAME).startsWith('PR-')
}

def isMasterBranch() {
    return env.BRANCH_NAME == "master"
}

def isReleaseBranch() {
    return env.BRANCH_NAME.startsWith("rel")
}

def isMainReleaseBranch() {
    return env.BRANCH_NAME =~ ~/^(rel-)(\d+\.)?(\d+\.)?(\*|\d+)$/
}

def reportFlake8Violations(report) {
    def summary = createSummary(
            icon: "notepad.png",
            text: "<strong>code style violations</strong><br>"
    )
    summary.appendText("<pre>${report}</pre>", false)
    if (isPR()) {
        pullRequest.comment(
                "code style violations\n```\n${report}```\nPlease run `make lint` and fix reported violations."
        )
    }
}
